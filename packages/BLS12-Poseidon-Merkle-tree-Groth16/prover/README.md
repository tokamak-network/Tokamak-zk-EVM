# Tokamak Groth16 Prover

This component implements the Groth16 zero-knowledge proof generation for Tokamak's storage proof verification system. It generates cryptographic proofs that demonstrate knowledge of valid storage state without revealing the actual data.

## Overview

The prover takes storage data from up to 50 participants and generates a Groth16 proof that:
- The storage keys and values are correctly organized
- The Merkle tree construction is valid
- The computed Merkle root matches the expected value
- All constraints in the circuit are satisfied

## Architecture

### Components

- **`witness.rs`** - Witness generation from circuit inputs
- **`proof.rs`** - Groth16 proof generation and serialization
- **`poseidon.rs`** - BLS12-381 Poseidon hash implementation
- **`circuit_inputs.rs`** - Input validation and formatting
- **`bin/prover_demo.rs`** - Demo application showing end-to-end proof generation

### Dependencies

The prover uses the fixed trusted setup generated by the `trusted-setup` component:
- **Proving Key**: `../trusted-setup/output/proving_key.bin`
- **Verification Key**: `../trusted-setup/output/verification_key.bin`
- **R1CS Circuit**: `../build/main_optimized.r1cs`

## Quick Start

### Prerequisites

1. **Compiled Circuit**: Ensure the circuit is compiled
   ```bash
   cd ../circuits && npm run compile-full
   ```

2. **Trusted Setup**: Generate the fixed trusted setup
   ```bash
   cd ../trusted-setup && cargo run --bin generate_fixed_setup
   ```

### Running the Prover Demo

```bash
# From the prover directory
cargo run --bin prover_demo
```

This will:
1. Load the trusted setup from `../trusted-setup/output/`
2. Generate test storage data (5 participants, channel ID 999)
3. Compute the expected Merkle root
4. Generate witness for the circuit
5. Create a Groth16 proof
6. Export proof and verification key to `output/`

### Expected Output

```
üöÄ === Tokamak Groth16 Prover Demo ===
üìã Step 1: Loading production trusted setup...
‚úÖ R1CS loaded from ../build/main_optimized.r1cs
‚úÖ Production trusted setup loaded successfully
üìù Step 2: Creating test circuit inputs...
üßÆ Step 3: Generating circuit witness...
üîí Step 4: Generating Groth16 proof...
üíæ Step 5: Saving proof to output directory...
üéâ === Prover Demo Completed Successfully! ===
```

### Generated Files

All output files are saved to `prover/output/`:
- **`proof.json`** - Groth16 proof in JSON format for verification
- **`verification_key.json`** - Public verification parameters

## Circuit Inputs

### Public Inputs (3 total)
- **`merkle_root`** - Expected Merkle root hash of the storage tree
- **`active_leaves`** - Number of active participants (‚â§50)
- **`channel_id`** - Unique channel identifier

### Private Inputs (100 total)
- **`storage_keys[50]`** - Storage keys for each participant
- **`storage_values[50]`** - Storage values for each participant

## Usage Examples

### Basic Proof Generation

```rust
use tokamak_groth16_prover::{CircuitInputs, WitnessGenerator, Groth16Prover, Result};
use tokamak_groth16_trusted_setup::{R1CS, ProductionSetup};
use icicle_bls12_381::curve::ScalarField;

// Load trusted setup
let r1cs = R1CS::load_from_file("../build/main_optimized.r1cs")?;
let setup = ProductionSetup::load_fixed_setup("../trusted-setup/output", &r1cs)?;

// Create circuit inputs
let inputs = CircuitInputs {
    merkle_root: ScalarField::zero(), // Will be computed
    active_leaves: ScalarField::from([5u32, 0, 0, 0, 0, 0, 0, 0]),
    channel_id: ScalarField::from([999u32, 0, 0, 0, 0, 0, 0, 0]),
    storage_keys: [ScalarField::zero(); 50],
    storage_values: [ScalarField::zero(); 50],
};

// Generate witness and proof
let witness_generator = WitnessGenerator::new()?;
let witness = witness_generator.generate_witness(&inputs)?;
let prover = Groth16Prover::new(setup.proving_key);
let proof = prover.prove_with_witness(&witness)?;

// Export proof
Groth16Prover::save_proof_json(&proof, "output/proof.json")?;
```

### Custom Storage Data

```rust
// Fill storage data for 10 participants
for i in 0..10 {
    inputs.storage_keys[i] = ScalarField::from([100 + i as u32, 0, 0, 0, 0, 0, 0, 0]);
    inputs.storage_values[i] = ScalarField::from([200 + i as u32, 0, 0, 0, 0, 0, 0, 0]);
}

// Compute correct Merkle root
inputs.merkle_root = witness_generator.compute_expected_merkle_root(
    &inputs.storage_keys, 
    &inputs.storage_values
)?;
```

## Performance

### Proof Generation Time
- **Circuit Size**: 37,199 constraints
- **Generation Time**: ~2-5 seconds (depending on hardware)
- **Memory Usage**: ~100-200 MB during proof generation

### Hardware Requirements
- **CPU**: Modern multi-core processor (x86_64 or ARM64)
- **RAM**: Minimum 512 MB, recommended 1 GB
- **Storage**: ~50 MB for trusted setup files

## Technical Details

### Cryptographic Primitives
- **Curve**: BLS12-381 elliptic curve
- **Hash Function**: Poseidon with 32 rounds (4+24+4 structure)
- **Proof System**: Groth16 zkSNARK
- **Field Operations**: 255-bit prime field arithmetic

### Security Properties
- **Zero-Knowledge**: Proofs reveal no information about private inputs
- **Soundness**: Invalid statements cannot be proven (with overwhelming probability)
- **Completeness**: Valid statements can always be proven
- **Succinctness**: Constant-size proofs (~200 bytes) regardless of circuit size

### Circuit Statistics
- **Variables**: 37,235 total
- **Public Inputs**: 3 (merkle_root, active_leaves, channel_id)
- **Private Inputs**: 100 (50 keys + 50 values)
- **Constraints**: 37,199 total (14,268 non-linear + 22,931 linear)

## Troubleshooting

### Common Issues

**Error: "Cannot load trusted setup for fixed circuit"**
```bash
# Solution: Generate the trusted setup first
cd ../trusted-setup && cargo run --bin generate_fixed_setup
```

**Error: "R1CS file not found"**
```bash
# Solution: Compile the circuit first
cd ../circuits && npm run compile-full
```

**Error: "Powers of Tau insufficient"**
- This indicates a mismatch between circuit size and trusted setup
- Regenerate the trusted setup to match the current circuit

### Debug Mode

Run with debug logging for detailed information:
```bash
RUST_LOG=debug cargo run --bin prover_demo
```

### Memory Issues

For memory-constrained environments:
- Ensure at least 1 GB available RAM
- Close other applications during proof generation
- Consider using release mode: `cargo run --release --bin prover_demo`

## Integration

### JSON Output Format

The generated `proof.json` contains:
```json
{
  "a": ["0x...", "0x..."],
  "b": [["0x...", "0x..."], ["0x...", "0x..."]],
  "c": ["0x...", "0x..."],
  "public_inputs": ["0x...", "0x...", "0x..."]
}
```

### Verification

The proof can be verified using:
1. **On-chain**: Deploy Solidity verifier contract with `verification_key.json`
2. **Off-chain**: Use the verifier component in this repository
3. **Third-party**: Any Groth16 verifier supporting BLS12-381

## Development

### Building

```bash
# Debug build
cargo build

# Release build (optimized)
cargo build --release

# Run tests
cargo test
```

### Adding New Features

1. **Custom Inputs**: Modify `CircuitInputs` struct
2. **New Hash Functions**: Implement in `poseidon.rs`
3. **Different Curves**: Update dependencies and field operations

### Testing

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_witness_generation

# Run with output
cargo test -- --nocapture
```

## License

MIT License - see LICENSE file for details.

## Contributing

1. Ensure all tests pass: `cargo test`
2. Format code: `cargo fmt`
3. Check linting: `cargo clippy`
4. Update documentation for any API changes