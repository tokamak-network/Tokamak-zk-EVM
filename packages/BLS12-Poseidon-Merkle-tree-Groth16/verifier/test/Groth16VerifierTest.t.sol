// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

import "../forge-std/src/Test.sol";
import "../src/merkle_tree_verifier.sol";

contract Groth16VerifierTest is Test {
    Groth16Verifier public verifier;

    function setUp() public {
        verifier = new Groth16Verifier();
    }

    function testVerifyValidProof() public {
        // Test data from proof.json and public.json generated by the circuit

        // Proof points from proof.json (BLS12-381 format - PART1/PART2 split)
        bytes32[2][2] memory pA = [
            [bytes32(0x00000000000000000000000000000000047294158f282001db023125502de032), bytes32(0x1696daa24b91bf291189f4b7021586fafde4aff77b662c69a904934485022939)],
            [bytes32(0x000000000000000000000000000000000cf2cccc37bf204a666454c4f3cd87d5), bytes32(0xb9c8cecc46c1f1dc6fa9bb2e212a245f692a84aa0411a2dfd9dc84b519693f90)]
        ];

        bytes32[2][2][2] memory pB = [
            [
                [bytes32(0x0000000000000000000000000000000016b09ea0e4e48d741136778237801972), bytes32(0x285db0ab43bb83a94d188742badc0738114360cfc07ddd362bd2b373f08092b7)],
                [bytes32(0x000000000000000000000000000000000d38c7d417bae6bbcb284cdd013cb197), bytes32(0x90e3880d0615b4d896940fcb120e9df84b29e09632aac7a162d0841d746498d0)]
            ],
            [
                [bytes32(0x0000000000000000000000000000000006c2f10561de7b4487fabeff08c00851), bytes32(0xb302bad823e87f647070c6c649254c1442eb3a2c7db637c1e512f6dfb63707dd)],
                [bytes32(0x0000000000000000000000000000000018f39e5790f8dab6acc3d35549fc35f6), bytes32(0x09cd82b621f56877cc6f3954d14371b6348498dac6e212cff7cca9600a2684db)]
            ]
        ];

        bytes32[2][2] memory pC = [
            [bytes32(0x0000000000000000000000000000000001668f324d79b1d484d595850b075d6f), bytes32(0x40e21a23be8a2054f2a12dab803a7c232680b2a4b9af760cb9ef9da9ce438fe3)],
            [bytes32(0x00000000000000000000000000000000064ee1541d630969df07bf6066d735f3), bytes32(0x9a6dca6f9c5497289cb5cc7f50ae143edd2b77dc1834e90ffbc45afe851d2091)]
        ];

        // Public signals from public.json (101 signals total)
        bytes32[101] memory pubSignals = [
            bytes32(0x4ec3e0aa0bf5311131458bae664c50ab0ca8dbd79efaa6f30314f9194c533b99), bytes32(uint256(0x64)), bytes32(uint256(0xc8)), bytes32(uint256(0x6e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0xa)), bytes32(uint256(0x14)), bytes32(uint256(0x1e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0))
        ];

        // Verify the proof
        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);
        
        // Assert that the proof is valid
        assertTrue(isValid, "Valid proof should be accepted by the verifier");
    }

    function testVerifyInvalidProof() public {
        // Test with invalid proof data (modified pA)
        bytes32[2][2] memory invalidPA = [
            [bytes32(uint256(123456789)), bytes32(uint256(987654321))],  // Invalid values
            [bytes32(uint256(111111111)), bytes32(uint256(222222222))]   // Invalid values
        ];

        bytes32[2][2][2] memory pB = [
            [
                [bytes32(0x0000000000000000000000000000000016b09ea0e4e48d741136778237801972), bytes32(0x285db0ab43bb83a94d188742badc0738114360cfc07ddd362bd2b373f08092b7)],
                [bytes32(0x000000000000000000000000000000000d38c7d417bae6bbcb284cdd013cb197), bytes32(0x90e3880d0615b4d896940fcb120e9df84b29e09632aac7a162d0841d746498d0)]
            ],
            [
                [bytes32(0x0000000000000000000000000000000006c2f10561de7b4487fabeff08c00851), bytes32(0xb302bad823e87f647070c6c649254c1442eb3a2c7db637c1e512f6dfb63707dd)],
                [bytes32(0x0000000000000000000000000000000018f39e5790f8dab6acc3d35549fc35f6), bytes32(0x09cd82b621f56877cc6f3954d14371b6348498dac6e212cff7cca9600a2684db)]
            ]
        ];

        bytes32[2][2] memory pC = [
            [bytes32(0x0000000000000000000000000000000001668f324d79b1d484d595850b075d6f), bytes32(0x40e21a23be8a2054f2a12dab803a7c232680b2a4b9af760cb9ef9da9ce438fe3)],
            [bytes32(0x00000000000000000000000000000000064ee1541d630969df07bf6066d735f3), bytes32(0x9a6dca6f9c5497289cb5cc7f50ae143edd2b77dc1834e90ffbc45afe851d2091)]
        ];

        bytes32[101] memory pubSignals = [
            bytes32(0x4ec3e0aa0bf5311131458bae664c50ab0ca8dbd79efaa6f30314f9194c533b99), bytes32(uint256(0x64)), bytes32(uint256(0xc8)), bytes32(uint256(0x6e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0xa)), bytes32(uint256(0x14)), bytes32(uint256(0x1e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0))
        ];

        // Verify the invalid proof
        bool isValid = verifier.verifyProof(invalidPA, pB, pC, pubSignals);
        
        // Assert that the invalid proof is rejected
        assertFalse(isValid, "Invalid proof should be rejected by the verifier");
    }

    function testVerifyInvalidPublicSignals() public {
        // Test with valid proof but invalid public signals
        bytes32[2][2] memory pA = [
            [bytes32(0x00000000000000000000000000000000047294158f282001db023125502de032), bytes32(0x1696daa24b91bf291189f4b7021586fafde4aff77b662c69a904934485022939)],
            [bytes32(0x000000000000000000000000000000000cf2cccc37bf204a666454c4f3cd87d5), bytes32(0xb9c8cecc46c1f1dc6fa9bb2e212a245f692a84aa0411a2dfd9dc84b519693f90)]
        ];

        bytes32[2][2][2] memory pB = [
            [
                [bytes32(0x0000000000000000000000000000000016b09ea0e4e48d741136778237801972), bytes32(0x285db0ab43bb83a94d188742badc0738114360cfc07ddd362bd2b373f08092b7)],
                [bytes32(0x000000000000000000000000000000000d38c7d417bae6bbcb284cdd013cb197), bytes32(0x90e3880d0615b4d896940fcb120e9df84b29e09632aac7a162d0841d746498d0)]
            ],
            [
                [bytes32(0x0000000000000000000000000000000006c2f10561de7b4487fabeff08c00851), bytes32(0xb302bad823e87f647070c6c649254c1442eb3a2c7db637c1e512f6dfb63707dd)],
                [bytes32(0x0000000000000000000000000000000018f39e5790f8dab6acc3d35549fc35f6), bytes32(0x09cd82b621f56877cc6f3954d14371b6348498dac6e212cff7cca9600a2684db)]
            ]
        ];

        bytes32[2][2] memory pC = [
            [bytes32(0x0000000000000000000000000000000001668f324d79b1d484d595850b075d6f), bytes32(0x40e21a23be8a2054f2a12dab803a7c232680b2a4b9af760cb9ef9da9ce438fe3)],
            [bytes32(0x00000000000000000000000000000000064ee1541d630969df07bf6066d735f3), bytes32(0x9a6dca6f9c5497289cb5cc7f50ae143edd2b77dc1834e90ffbc45afe851d2091)]
        ];

        // Invalid public signals (modified the merkle root)
        bytes32[101] memory invalidPubSignals = [
            bytes32(uint256(0xabcdef123456789)), bytes32(uint256(0x64)), bytes32(uint256(0xc8)), bytes32(uint256(0x6e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0xa)), bytes32(uint256(0x14)), bytes32(uint256(0x1e)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)), bytes32(uint256(0)),
            bytes32(uint256(0))
        ];

        // Verify with invalid public signals
        bool isValid = verifier.verifyProof(pA, pB, pC, invalidPubSignals);
        
        // Assert that the proof with invalid public signals is rejected
        assertFalse(isValid, "Proof with invalid public signals should be rejected");
    }
}