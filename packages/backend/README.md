# Tokamak-zk-EVM/backend

## What are the backend algorithms

The three algorithms, "setup", "prove", and "verify", are rust implementation of the backend algorithms defined in [the Tokamak zk-SNARK manuscript](https://eprint.iacr.org/2024/507).
They take a zkp circuit specialized for a transaction as their input. The circuit should be pre-processed by [the frontend compilers](../frontend/).
More specifically,
- setup/trusted-setup: it takes a library of subcircuits generated by [the QAP-compiler](../frontend/qap-compiler/) as input and generates a reference string and commitments to the subcircuit library.
- prove: it takes the subcircuit library and the transaction-specific details generated by [the Synthesizer](../frontend/synthesizer) as input and generates a zk proof.
- verify: it takes public inputs, the setup outputs, and the zk proof as input and accept or reject the proof.

## How to use?
### Prerequisite
- Install Node.js – https://nodejs.org/
- Install Circom – https://docs.circom.io/getting-started/installation/
- Install Rust – https://www.rust-lang.org/tools/install
- Install CMake – https://cmake.org/download/
- Make sure that you have run [Synthesizer](../frontend/synthesizer/README.md).
- Make sure that you have installed [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) on your VS Code as an extension.

### Run the backend in a debugging mode with CodeLLDB
- Go to the `Run and Debug` menu on the left side of your VS Code.
- Open the dropdown box at the top and select the algorithm you want to debug.
- Click the `Start Debugging (F5)` button.

## Description for the Setup input and output
### Input
The setup (both trusted- and MPC-setups) requires the only input from the QAP-compiler, which is [a library of subcircuits](../frontend/qap-compiler/subcircuits/library). This input would be more likely fixed. It will be changed whenever there is a change in the EVM's spec.
### Output
You can find the setup outputs in [the "output" folder](./setup/trusted-setup/output):
- `combined_sigma.rkyv` (for prove)
- `sigma_verify.rkyv` (for verify)
- `sigma_preprocess.rkyv` (for preprocess)
These outputs rarely change, as they depend on the EVM spec.


## Description for the Prove input and output
### Input
The prove takes its input from the following three paths:
- The setup outputs,
- [A library of subcircuits](../frontend/qap-compiler/subcircuits/library) generated by the QAP-compiler, and
- transaction-specific details such as the subcircuits combination, wire map, instances, and witnesses analyzed by the Synthesizer.
### Output
- Zk proof of correct execution of a transaction


## Description for the Verify input and output
### Input
The verify takes its input from the following three paths:
- The setup outputs,
- The zk proof, and
- [Public inputs](../frontend/synthesizer/examples/outputs/publicInstance.json) provided by the Synthesizer.
### Output
- It will display a message "true", if the zk proof is verified.

## Timing report (prove)
We provide a human-readable timing report generated from raw timing data:
- Report: [prove/output/timing.release.md](prove/output/timing.release.md)
- Raw data: [prove/optimization/timing.release.json](prove/optimization/timing.release.json)

The report is **auto-generated** from the JSON using:
```
python3 prove/optimization/scripts/timing_to_md.py --input prove/optimization/timing.release.json --output prove/output/timing.release.md
```
If you re-run the timing test, regenerate the report with the command above to keep them in sync.

To run the timing test from VS Code and view output in the Debug Console:
1. Open **Run and Debug**.
2. Select **Test prove timing (timing feature)**.
3. Start debugging (F5).

## Contributing
We welcome contributions! Please see our [Contributing Guidelines](../../CONTRIBUTING.md) for details.

## Original contribution
- [JehyukJang](https://github.com/JehyukJang): Algorithms design, analysis, implementation, and optimization.
- [jason hwang](https://github.com/cd4761): Parallel computing-relevant optimization of the implementations.

## License
[MPL-2.0]
